# 航迹管理模块 | TrackManager
一个简单的类，用来管理航迹并进行可视化。

---
## 环境依赖
  - Catch2 (v3.x) 仅测试用，可选
  - Spdlog (>=1.5.0) 日志系统
---
## 项目概述
1. **使用方式**
   - 所有对外接口函数均在include文件下，引用trackerManager.hpp即可。编译CPP文件以LIB方式提供服务
   - 测试文件在tests文件夹下
2. **文件结构**
   - 头文件 [`include`](./include/)
   - 源文件 [`src`](./src/)
   - 三方库 [`utils`](./utils/)
   - 测试代码 [`tests`](./tests/)
   - 自动构建脚本 [`bmain.sh`](./bmain.sh)：
3. **代码结构**
   - 泛型环形存储容器： **latestKbuffer\<T\>**
     - 循环存储，自动覆盖旧数据；能定点修改航迹点
   - 航迹管理组件：**TrackerManager**
     - 航迹记录（数据层）、终结管理；事务管理；
     - 调用latestKbuffer\<trackerContainer\>实现
   - 可视化组件：**TrackerVisualizer**
     - 本站可视化： 基于 OpenCV 实现了航迹数据的基础可视化，具备航线和航迹号显示功能
     - 整个流水线数据的可视化由通信组件实现，发送到对应端口,由HTML绘制
     - 航迹管理组件TrackerManager的友元
   - 通信组件：**TrackerComm**
     - 端口由commondata::Config结构体解析得到，禁止热重载
     - 发送JSON数据，同时发送点迹信息和航迹信息
     - 监听端口，接收命令，执行控制
     - 航迹管理组件TrackerManager的友元
   - **管理服务层**：**ManagementService**
     - 受流水线控制，当数据到达时，通过通信组件TrackerComm发送数据包到目的地
     - 调用TrackerManager、TrackerVisualizer,TrackerComm实现

## 开发日志  
### 2025-10-24 至 2025-10-25
1. **项目框架搭建**
2. **开发工具链集成**
   - 完成VSCode集成GDB调试
   - Git 版本控制（已配置 `.gitignore` 过滤构建产物）
3. **结构设计**
   - latestKbuffer\<T\> ：泛型环形存储容器：循环存储，自动覆盖旧数据；能定点修改航迹点
   - TrackerManager - 航迹生命周期管理器：航迹记录（数据层）、终结管理；事务管理；
   - trackshow -可视化窗口：DEBUG功能用于显示航迹，两个函数接口，读取trackManager的航迹并可视化，另一个是读取外部输入的点迹进行可视化

### 2025-10-26 至 2025-10-26
1. **构建数据层：latestKbuffer\<T\>**
  - 基于环形缓冲区思路设计，仅保留最新的k个数据，数据满的时候自动弹出
  - 目前设计为禁止拷贝容器
  - 仅允许追加写入新x数据和定点修改数据，禁止移除数据**(已移除该功能放到应用层实现)**
  - 批量拷贝输出：智能内存拷贝策略，POD类型使用memcpy，非POD类型使用安全循环
  
### 2025-10-27 至 2025-11-2
1. 删除计算层：由卡尔曼滤波提供外推结果
   - 设计动机：为解决模块间紧耦合问题，提升系统可拆卸性与可维护性，放弃传统的计算层设计。
   - 统一缓冲区结构，航迹结构放到defstruct里面去，缓冲区结构
   - 设计指令结构用于各层通信
2. **航迹管理层设计**
   - 调用latestKBuffer，设计内存池
   - 提供航迹创建，航迹删除，航迹合并（同传感器合批），航迹输出服务
   - 提供航迹更新功能，且自动实现单群识别，航迹判断
   - 支持一键初始化所有航迹
  
### 2025-11-3 至 2025-11-04
1. **日志库**
    - 添加./utils三方库，输出日志
    - 依旧支持插拔设计和异常检测
    - 暂时还没有支持args的写入，等待后续完善
2. 添加友元TrackerManagerDebugger实现航迹管理层调试功能
3. **管理服务层**
    - 去耦合，将对外接口重构为新服务层，组合调用可视化插件，日志插件和航迹管理层
    - 和流水线结构对接，前后端分离
4. 准备重写DEFSTRUCT，完善流水线设计思路

  
### 2025-11-05 至 2025-11-06
1. 完成defstruct流水线结构设计
    - 统一了缓冲区结构，将航迹结构整合到defstruct中
    - 设计了指令结构用于各层间通信，提升模块解耦性
2. 代码质量优化与警告消除
    - 启用三级编译警告（基础警告、UB检测、代码质量），截至11.06没有WARNING了
    - 修复了所有类型转换警告，将非内存相关的size_t统一为std::uint32_t，（基础数据类型任然支持size_t）
3. 确保跨平台数据类型一致性，为未来流水线分离做准备
    - 完成压力测试与性能验证：RELEASE下：
    - 航迹创建: 10.77 μs/个 (2000空航迹)
    - 航迹删除: 10.46 μs/个 (2000满载航迹)
    - 点迹写入: 0.0145 μs/点 (400万点迹)
    - 数据打包: 14.19 ms (244MB数据)
    - 所有核心操作性能均衡，内存池设计达到预期效果
4. 准备开始可视化插件（优先），日志插件（尤其是把string修改为args这个有点急），以及流水线兼容的设计

### 2025-11-07 至 2025-11-08
1. 插件分离：可视化插件拆解为通信插件和显示插件，代表了可视化和接口可视化两个方向
    - 通信插件:1. 支持控制命令实现航迹融合;2. 配置通过Config结构体管理;
    - 可视化插件用OPENCV实现，反正霍夫变换之类的迟早用得上
2. 统一命名规范，加了一堆namespace
3. 出差去了，开发中止

### 2025-11-29 至 2025-11-30
1. 日志插件重构
   - 宏控制机制：支持条件编译切换日志模式或std::cout/std::cerr
   - 退化方式： LOG_DEBUG退化为无输出，LOG_INFO退化为cout，LOG_ERROR退化为cerr
2. 通信插件完善
   - 发送跟踪结果到指定端口
   - 接收控制信息实现航迹融合
3. 本地可视化插件完成，完全形态由通信库结合JS+HTML来实现：
   - 基于 OpenCV 实现了航迹数据的实时可视化显示，进行了全面的单元测试和压力测试
   - 航迹线绘制：黑色渐变线条，新点透明度高，历史点透明度低，新点标注航迹号
   - 经纬度坐标转换：自动映射到图像坐标系
   - 本站数据实时刷新：支持动态更新显示，足够支持单站流水线
      | 航迹数 | 航迹长度 | 总点数 | 平均绘制时间(ms) | 刷新频率(FPS) |
      | ------ | -------- | ------ | ---------------- | ------------- |
      | 500    | 100      | 5万    | 55.269           | 18.1          |
      | 500    | 500      | 25万   | 75.538           | 13.2          |
      | 500    | 1000     | 50万   | 112.364          | 8.9           |
      | 1000   | 100      | 10万   | 92.195           | 10.8          |
      | 1000   | 500      | 50万   | 148.728          | 6.7           |
      | 1000   | 1000     | 100万  | 219.968          | 4.5           |
      | 1500   | 100      | 15万   | 131.268          | 7.6           |
      | 1500   | 500      | 75万   | 220.092          | 4.5           |
      | 1500   | 1000     | 150万  | 328.078          | 3.0           |
4. 此外：外面的CMAKE链接完毕后，内部也要链接一下，不然任然有可能出现找不到某个库的问题
5. 发现耦合度过高，准备进行去耦合，将打包函数从航迹管理器中移除，放到通信类中——开始改动通信类

### 2025-12-1 
1. 添加了UDPBASIC作为通信库基类
2. 计划添加事件循环来写TrackerComm类，或者把comm类直接删了然后放到service里面直接用。。不然感觉内容太单薄了